"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pageGenerator = pageGenerator;
const react_1 = require("@nx/react");
const devkit_1 = require("@nx/devkit");
const styles_1 = require("../../utils/styles");
const artifact_name_and_directory_utils_1 = require("@nx/devkit/src/generators/artifact-name-and-directory-utils");
/*
 * This schematic is basically the React component one, but for Next we need
 * extra dependencies for css, sass, less style options, and make sure
 * it is under `pages` folder.
 */
async function pageGenerator(host, schema) {
    const options = await normalizeOptions(host, schema);
    const componentTask = await (0, react_1.componentGenerator)(host, {
        ...options,
        isNextPage: true,
        export: false,
        classComponent: false,
        routing: false,
        skipTests: !options.withTests,
        skipFormat: true,
    });
    const project = (0, devkit_1.readProjectConfiguration)(host, options.projectName);
    const styledTask = (0, styles_1.addStyleDependencies)(host, {
        style: options.style,
        swc: !host.exists((0, devkit_1.joinPathFragments)(project.root, '.babelrc')),
    });
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    return (0, devkit_1.runTasksInSerial)(componentTask, styledTask);
}
async function normalizeOptions(host, options) {
    // Get the project name first so we can determine the router directory
    const { project: determinedProjectName } = await (0, artifact_name_and_directory_utils_1.determineArtifactNameAndDirectoryOptions)(host, {
        name: options.name,
        path: options.path,
    });
    const project = (0, devkit_1.readProjectConfiguration)(host, determinedProjectName);
    // app/ is a reserved folder in nextjs so it is safe to check it's existence
    const isAppRouter = host.exists(`${project.root}/app`) ||
        host.exists(`${project.root}/src/app`);
    let pageSymbolName = options.name;
    if (!pageSymbolName) {
        // if `name` is not provided, we use the last segment of the path
        if (options.path !== '.' && options.path !== '') {
            pageSymbolName = options.path.split('/').pop();
        }
        else {
            // the user must have cd into a previously created directory, we need to
            // resolve the cwd to get it
            const cwd = (0, artifact_name_and_directory_utils_1.getRelativeCwd)();
            if (cwd !== '.' && cwd !== '') {
                pageSymbolName = cwd.split('/').pop();
            }
            else {
                // this can only happen when running from the workspace root, in which
                // case, we don't have a good way to automatically determine the name
                throw new Error('Cannot determine the page name, please provide a `name` or `path` option.');
            }
        }
    }
    const { project: projectName, filePath } = await (0, artifact_name_and_directory_utils_1.determineArtifactNameAndDirectoryOptions)(host, {
        name: pageSymbolName,
        path: (0, devkit_1.joinPathFragments)(options.path, isAppRouter ? 'page.tsx' : 'index.tsx'),
    });
    return {
        ...options,
        path: filePath,
        projectName,
    };
}
exports.default = pageGenerator;
